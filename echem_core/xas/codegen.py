"""
XAS code generation utilities.

Generates standalone Python scripts that reproduce XAS normalization and analysis
from raw H5 files. Data processing and plotting are strictly separated.
"""

from datetime import datetime
from typing import Optional

# =============================================================================
# HEADER TEMPLATE
# =============================================================================

HEADER_TEMPLATE = '''#!/usr/bin/env python3
"""
XAS Normalization Script
Generated by echem-viewer (https://github.com/helenengelhardt/echem-viewer)

Generated: {timestamp}
Sample: {sample}
Dataset: {dataset}
ROI: {roi} ({element})
Scans averaged: {scan_list}

This script reproduces the XAS normalization workflow. It is self-contained
and requires only: h5py, numpy, larch, and {plotting_lib}.

Data processing (Sections 1-3) is independent of plotting (Section 4).
"""

'''

# =============================================================================
# SECTION 1: CONFIGURATION TEMPLATE
# =============================================================================

CONFIG_TEMPLATE = '''# =============================================================================
# SECTION 1: CONFIGURATION
# All parameters are editable - modify as needed to adjust the analysis
# =============================================================================

# H5 file path (update to your local path)
H5_FILE = "{h5_file}"

# Scans to average (these were marked as "good" during review)
SCAN_KEYS = {scan_keys}

# H5 file structure (beamline-specific paths)
H5_PATHS = {h5_paths}
PARENT_PATH = "{parent_path}"

# Signal channels
NUMERATOR = "{numerator}"
DENOMINATOR = {denominator}  # None if not using denominator

# Normalization parameters (relative to E0 in eV)
# These values were determined during scan review
SCAN_NORM_PARAMS = {scan_norm_params}

# Energy calibration
ENERGY_SHIFT = {energy_shift}  # eV (applied to align to reference)

# Energy filtering (in keV, None to disable)
ENERGY_MIN = {energy_min}
ENERGY_MAX = {energy_max}

'''

# =============================================================================
# SECTION 2: DATA LOADING TEMPLATE
# =============================================================================

DATA_LOADING_TEMPLATE = '''# =============================================================================
# SECTION 2: DATA LOADING
# Functions to read raw data from H5 files
# =============================================================================

import h5py
import numpy as np


def read_scan_data(h5_file: str, scan_key: str) -> tuple:
    """
    Read energy and mu from H5 file for a single scan.

    Returns
    -------
    energy_eV : np.ndarray
        Energy in eV
    mu : np.ndarray
        Absorption coefficient (numerator/denominator)
    """
    with h5py.File(h5_file, "r") as f:
        instrument = f[scan_key][PARENT_PATH]

        # Read energy (stored in keV)
        energy_keV = instrument[H5_PATHS["energy"]]["data"][:]

        # Read numerator
        numerator_data = instrument[H5_PATHS[NUMERATOR]]["data"][:]

        # Apply denominator if specified
        if DENOMINATOR:
            denominator_data = instrument[H5_PATHS[DENOMINATOR]]["data"][:]
            mu = numerator_data / denominator_data
        else:
            mu = numerator_data

    # Apply energy filtering
    if ENERGY_MIN is not None or ENERGY_MAX is not None:
        mask = np.ones(len(energy_keV), dtype=bool)
        if ENERGY_MIN is not None:
            mask &= energy_keV >= ENERGY_MIN
        if ENERGY_MAX is not None:
            mask &= energy_keV <= ENERGY_MAX
        energy_keV = energy_keV[mask]
        mu = mu[mask]

    # Convert keV to eV and apply energy shift
    energy_eV = energy_keV * 1000 + ENERGY_SHIFT

    return energy_eV, mu

'''

# =============================================================================
# SECTION 3: PROCESSING TEMPLATE
# =============================================================================

PROCESSING_TEMPLATE = '''# =============================================================================
# SECTION 3: DATA PROCESSING
# Normalization and averaging using Larch
# =============================================================================

from larch import Group
from larch.xafs import pre_edge


def normalize_scan(energy: np.ndarray, mu: np.ndarray, params: dict) -> dict:
    """
    Normalize a single XAS scan using Larch pre_edge.

    Parameters
    ----------
    energy : np.ndarray
        Energy in eV
    mu : np.ndarray
        Raw absorption coefficient
    params : dict
        Normalization parameters (pre1, pre2, norm1, norm2)

    Returns
    -------
    dict with keys: energy, mu, norm, e0, edge_step, pre_edge, post_edge
    """
    dat = Group()
    dat.energy = energy
    dat.mu = mu

    # Run Larch pre_edge normalization
    pre_edge(
        dat,
        group=dat,
        pre1=params.get("pre1"),
        pre2=params.get("pre2"),
        norm1=params.get("norm1"),
        norm2=params.get("norm2"),
    )

    return {
        "energy": dat.energy,
        "mu": dat.mu,
        "norm": dat.norm,
        "e0": float(dat.e0),
        "edge_step": float(dat.edge_step),
        "pre_edge": dat.pre_edge,
        "post_edge": dat.post_edge,
    }


def normalize_and_average() -> dict:
    """
    Normalize all scans and compute average.

    Returns
    -------
    dict with keys:
        energy : np.ndarray - Energy in eV
        norm : np.ndarray - Averaged normalized absorption
        e0 : float - Average edge energy
        n_scans : int - Number of scans averaged
        individual_scans : list - Individual normalized scan data
    """
    normalized_scans = []

    for scan_key in SCAN_KEYS:
        # Read raw data
        energy, mu = read_scan_data(H5_FILE, scan_key)

        # Get normalization parameters for this scan
        params = SCAN_NORM_PARAMS.get(scan_key, {{}})

        # Normalize
        result = normalize_scan(energy, mu, params)
        result["scan_key"] = scan_key
        normalized_scans.append(result)

        print(f"  Normalized scan {{scan_key}}: E0 = {{result['e0']:.1f}} eV")

    # Average
    avg_energy = normalized_scans[0]["energy"]
    avg_norm = np.mean([s["norm"] for s in normalized_scans], axis=0)
    avg_e0 = np.mean([s["e0"] for s in normalized_scans])

    return {{
        "energy": avg_energy,
        "norm": avg_norm,
        "e0": avg_e0,
        "n_scans": len(normalized_scans),
        "individual_scans": normalized_scans,
    }}


def calculate_derivative(energy: np.ndarray, data: np.ndarray, order: int = 1) -> np.ndarray:
    """
    Calculate derivative of XAS data.

    Parameters
    ----------
    energy : np.ndarray
        Energy in eV
    data : np.ndarray
        Normalized absorption data
    order : int
        1 for first derivative, 2 for second derivative

    Returns
    -------
    np.ndarray
        Derivative array
    """
    dE = np.mean(np.diff(energy))
    deriv = np.gradient(data, dE)
    if order == 2:
        deriv = np.gradient(deriv, dE)
    return deriv

'''

# =============================================================================
# SECTION 4: MATPLOTLIB PLOTTING TEMPLATE
# =============================================================================

MATPLOTLIB_PLOT_TEMPLATE = '''# =============================================================================
# SECTION 4: PLOTTING (Matplotlib)
# Publication-quality static plots
# =============================================================================

import matplotlib.pyplot as plt


def plot_normalized(result: dict, output_prefix: str = "xas_normalized"):
    """
    Generate normalized XAS plot with matplotlib.

    Parameters
    ----------
    result : dict
        Output from normalize_and_average()
    output_prefix : str
        Prefix for output files (will create .png and .pdf)
    """
    energy = result["energy"]
    norm = result["norm"]
    e0 = result["e0"]

    fig, ax = plt.subplots(figsize=(8, 6))

    # Plot normalized data
    ax.plot(energy, norm, "b-", linewidth=1.5, label="Normalized")

    # Mark E0
    ax.axvline(e0, color="r", linestyle="--", linewidth=1, label=f"E0 = {{e0:.1f}} eV")

    # Labels
    ax.set_xlabel("Energy (eV)", fontsize=12, fontweight="bold")
    ax.set_ylabel("Normalized Absorption", fontsize=12, fontweight="bold")
    ax.set_title(f"XAS - {{result['n_scans']}} scans averaged", fontsize=14)
    ax.legend(loc="best")
    ax.grid(True, linestyle=":", alpha=0.7)

    # Style
    for spine in ax.spines.values():
        spine.set_linewidth(1.5)
    ax.tick_params(width=1.5)

    plt.tight_layout()

    # Save
    fig.savefig(f"{{output_prefix}}.png", dpi=300, bbox_inches="tight")
    fig.savefig(f"{{output_prefix}}.pdf", bbox_inches="tight")
    print(f"Saved: {{output_prefix}}.png and {{output_prefix}}.pdf")

    return fig, ax


def plot_with_derivatives(result: dict, output_prefix: str = "xas_analysis"):
    """
    Generate 3-panel plot: normalized, 1st derivative, 2nd derivative.
    """
    energy = result["energy"]
    norm = result["norm"]
    e0 = result["e0"]

    # Calculate derivatives
    d1 = calculate_derivative(energy, norm, order=1)
    d2 = calculate_derivative(energy, norm, order=2)

    fig, axes = plt.subplots(3, 1, figsize=(8, 12), sharex=True)

    # Panel 1: Normalized
    ax = axes[0]
    ax.plot(energy, norm, "b-", linewidth=1.5)
    ax.axvline(e0, color="r", linestyle="--", linewidth=1)
    ax.set_ylabel("Norm. Absorption", fontsize=11)
    ax.set_title(f"XAS Analysis - {{result['n_scans']}} scans averaged")
    ax.grid(True, linestyle=":", alpha=0.7)

    # Panel 2: First derivative
    ax = axes[1]
    ax.plot(energy, d1, "g-", linewidth=1.5)
    ax.axvline(e0, color="r", linestyle="--", linewidth=1)
    ax.set_ylabel("d(norm)/dE", fontsize=11)
    ax.grid(True, linestyle=":", alpha=0.7)

    # Panel 3: Second derivative
    ax = axes[2]
    ax.plot(energy, d2, "m-", linewidth=1.5)
    ax.axvline(e0, color="r", linestyle="--", linewidth=1)
    ax.set_xlabel("Energy (eV)", fontsize=12, fontweight="bold")
    ax.set_ylabel("d2(norm)/dE2", fontsize=11)
    ax.grid(True, linestyle=":", alpha=0.7)

    plt.tight_layout()

    fig.savefig(f"{{output_prefix}}.png", dpi=300, bbox_inches="tight")
    fig.savefig(f"{{output_prefix}}.pdf", bbox_inches="tight")
    print(f"Saved: {{output_prefix}}.png and {{output_prefix}}.pdf")

    return fig, axes

'''

# =============================================================================
# SECTION 4: PLOTLY PLOTTING TEMPLATE
# =============================================================================

PLOTLY_PLOT_TEMPLATE = '''# =============================================================================
# SECTION 4: PLOTTING (Plotly)
# Interactive plots
# =============================================================================

import plotly.graph_objects as go
from plotly.subplots import make_subplots


def plot_normalized(result: dict, output_prefix: str = "xas_normalized"):
    """
    Generate normalized XAS plot with Plotly.

    Parameters
    ----------
    result : dict
        Output from normalize_and_average()
    output_prefix : str
        Prefix for output files (will create .html)
    """
    energy = result["energy"]
    norm = result["norm"]
    e0 = result["e0"]

    fig = go.Figure()

    # Plot normalized data
    fig.add_trace(go.Scatter(
        x=energy,
        y=norm,
        mode="lines",
        name="Normalized",
        line=dict(color="blue", width=2)
    ))

    # Mark E0
    fig.add_vline(x=e0, line_dash="dash", line_color="red",
                  annotation_text=f"E0 = {{e0:.1f}} eV")

    # Layout
    fig.update_layout(
        title=f"XAS - {{result['n_scans']}} scans averaged",
        xaxis_title="Energy (eV)",
        yaxis_title="Normalized Absorption",
        template="plotly_white",
        font=dict(size=14),
        showlegend=True,
        height=500,
        width=800,
    )

    # Save
    fig.write_html(f"{{output_prefix}}.html")
    print(f"Saved: {{output_prefix}}.html")

    fig.show()
    return fig


def plot_with_derivatives(result: dict, output_prefix: str = "xas_analysis"):
    """
    Generate 3-panel plot: normalized, 1st derivative, 2nd derivative.
    """
    energy = result["energy"]
    norm = result["norm"]
    e0 = result["e0"]

    # Calculate derivatives
    d1 = calculate_derivative(energy, norm, order=1)
    d2 = calculate_derivative(energy, norm, order=2)

    fig = make_subplots(
        rows=3, cols=1,
        shared_xaxes=True,
        vertical_spacing=0.05,
        subplot_titles=("Normalized Absorption", "First Derivative", "Second Derivative")
    )

    # Panel 1: Normalized
    fig.add_trace(
        go.Scatter(x=energy, y=norm, mode="lines", name="Norm",
                   line=dict(color="blue", width=2)),
        row=1, col=1
    )

    # Panel 2: First derivative
    fig.add_trace(
        go.Scatter(x=energy, y=d1, mode="lines", name="d1",
                   line=dict(color="green", width=2)),
        row=2, col=1
    )

    # Panel 3: Second derivative
    fig.add_trace(
        go.Scatter(x=energy, y=d2, mode="lines", name="d2",
                   line=dict(color="purple", width=2)),
        row=3, col=1
    )

    # Add E0 lines to all panels
    for i in range(1, 4):
        fig.add_vline(x=e0, line_dash="dash", line_color="red", row=i, col=1)

    fig.update_layout(
        title=f"XAS Analysis - {{result['n_scans']}} scans averaged",
        height=900,
        width=800,
        template="plotly_white",
        showlegend=False,
    )
    fig.update_xaxes(title_text="Energy (eV)", row=3, col=1)

    fig.write_html(f"{{output_prefix}}.html")
    print(f"Saved: {{output_prefix}}.html")

    fig.show()
    return fig

'''

# =============================================================================
# SECTION 5: MAIN TEMPLATE
# =============================================================================

MAIN_TEMPLATE = '''# =============================================================================
# SECTION 5: MAIN
# =============================================================================

if __name__ == "__main__":
    print("XAS Normalization Script")
    print("=" * 50)
    print(f"H5 file: {{H5_FILE}}")
    print(f"Scans to average: {{len(SCAN_KEYS)}}")
    print()

    # Run normalization
    print("Normalizing scans...")
    result = normalize_and_average()

    print()
    print(f"Averaged {{result['n_scans']}} scans")
    print(f"Average E0: {{result['e0']:.1f}} eV")
    print()

    # Generate plots
    print("Generating plots...")
    plot_normalized(result)

    # Uncomment to also generate derivative plots:
    # plot_with_derivatives(result)

    print()
    print("Done!")
'''

# =============================================================================
# CODE GENERATION FUNCTION
# =============================================================================


def generate_xas_code(
    sample: str,
    dataset: str,
    roi_name: str,
    element: str,
    h5_file: str,
    scan_keys: list[str],
    scan_norm_params: dict[str, dict],
    numerator: str,
    denominator: Optional[str],
    h5_paths: dict,
    parent_path: str = "instrument",
    energy_shift: float = 0.0,
    energy_min: Optional[float] = None,
    energy_max: Optional[float] = None,
    plotting_backend: str = "matplotlib",
    include_derivatives: bool = False,
) -> str:
    """
    Generate standalone Python script for XAS normalization workflow.

    Parameters
    ----------
    sample : str
        Sample name
    dataset : str
        Dataset name
    roi_name : str
        ROI configuration name
    element : str
        Element being analyzed
    h5_file : str
        Path to H5 file
    scan_keys : list[str]
        List of scan keys to process (the "good" scans)
    scan_norm_params : dict
        Dict mapping scan_key -> {pre1, pre2, norm1, norm2}
    numerator : str
        Numerator channel name
    denominator : str or None
        Denominator channel name
    h5_paths : dict
        H5 path mappings for channels
    parent_path : str
        Parent path in H5 file
    energy_shift : float
        Energy calibration shift in eV
    energy_min, energy_max : float or None
        Energy filtering range in keV
    plotting_backend : str
        "matplotlib" or "plotly"
    include_derivatives : bool
        If True, generate derivative plotting code

    Returns
    -------
    str
        Complete Python script
    """
    timestamp = datetime.now().isoformat()

    # Select plotting template
    if plotting_backend == "plotly":
        plot_template = PLOTLY_PLOT_TEMPLATE
        plotting_lib = "plotly"
    else:
        plot_template = MATPLOTLIB_PLOT_TEMPLATE
        plotting_lib = "matplotlib"

    # Format scan list for display
    scan_list_str = ", ".join(scan_keys) if len(scan_keys) <= 5 else f"{scan_keys[0]}...{scan_keys[-1]} ({len(scan_keys)} scans)"

    # Build the script
    code_parts = [
        HEADER_TEMPLATE.format(
            timestamp=timestamp,
            sample=sample,
            dataset=dataset,
            roi=roi_name,
            element=element,
            scan_list=scan_list_str,
            plotting_lib=plotting_lib,
        ),
        CONFIG_TEMPLATE.format(
            h5_file=h5_file,
            scan_keys=repr(scan_keys),
            h5_paths=repr(h5_paths),
            parent_path=parent_path,
            numerator=numerator,
            denominator=repr(denominator),
            scan_norm_params=repr(scan_norm_params),
            energy_shift=energy_shift,
            energy_min=repr(energy_min),
            energy_max=repr(energy_max),
        ),
        DATA_LOADING_TEMPLATE,
        PROCESSING_TEMPLATE,
        plot_template,
        MAIN_TEMPLATE,
    ]

    return "".join(code_parts)
